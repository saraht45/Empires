<object clone="/obj/properties" owner="SkotOS">
  <Core:PropertyContainer>
    <Ur:UrObject/>
    <Core:PCProperties>
      <Core:Property property="export:id">
         "VirtualPlace"
      </Core:Property>
      <Core:Property property="export:log:creator">
         "Orcsuit"
      </Core:Property>
      <Core:Property property="merry:inherit:lib:log">
         \<Lib:chatlib\>
      </Core:Property>
      <Core:Property property="merry:lib:vp_arrival">
         X[M] /* 
** Do anything special that needs to be done when an object arrives at a place, 
**  including describing how they leave. 
** 
** Arguments: 
** 
**  \$movers - Array of objects that are leaving. 
**  \$id - The place they are leaving from. 
**  \$enterdetail - Optional string or Nref of the detail that the movers are 
**   leaving through.  If a string, it is assumed to be a detail of the place. 
** 
** Customizing: 
**  This function might be customized for many virtual systems. 
**  The primary purpose of this function is to just display emits of \$movers 
**  leaving; this may vary depending on situation.  Examples: 
**   [movers] arrive through [detail]. 
**    Bob leaves arrive a wooden door. 
**    The women arrive through an arch. 
**   [movers] [gait] in from [detail]. 
**    Mary walks in from a wooden door. 
**    John and Sue crawl in from through an arch. 
**   [movers] arrive from [detail], from the [direction]. 
**    Tom arrives from a sparse path, from the east. 
**    Beth and Jane arrive down a paved walkway, from the north. 
**  ...etc.  What's appropriate can vary; the factor most likely to make a 
**  that you can't really leave 'through' a path, as that makes little sense.  
** 
** Default Implementation: 
**  Just displays an emit, something like "Bob arrives via a door." 
**  Standard EmitTo person, EmitIn room for everyone else when just one mover. 
**  With multiple movers, an emit is generated for each possessed object in the 
**  room. 
*/ 
 
/*\$id is assumed to be valid*/ 
 
int i, n, detail; 
object placeob, *people, what; 
string *emit; 
 
/*We need movers and a place to move them from to do anything*/ 
if(!\$movers \|\| typeof(\$movers) != T_ARRAY \|\| sizeof(\$movers) == 0)\{ 
 return 0;\} 
 
placeob = Call(this, "vp_id_to_ob"); 
 
if(!placeob)\{ 
 return 0; 
\} 
 
/*Get the detail, if any*/ 
if(typeof(\$enterdetail) == T_STRING) 
\{ 
 \$enterdetail=NewNRef(placeob, \$enterdetail); 
\} 
if( typeof(\$enterdetail) == T_OBJECT \&\&  
    Get(NRefOb(\$enterdetail), "details:default:description:brief") ) 
\{ 
 detail=1; 
\} 
 
/*There's no easy way exclude multiple movers in an EmitIn, so if there's 
**more than one, do the emit by brute force; if just one, do it the easy way.*/ 
 
emit=allocate(4); 
\$placeobject = placeob; 
if(sizeof(\$movers) == 1) 
\{ 
 emit[0] = "You arrive at " + Describe(placeob, nil, \$movers[0]); 
 emit[1] = Describe(\$movers[0]) + " arrives"; 
 \$looker = \$movers[0]; 
 emit[3] = UnSAM(ParseXML("\<describe-view view=\\"\$(placeobject)\\" cap/\>")); 
 if(detail) 
 \{ 
  emit[2] = " via " + Describe(\$enterdetail) + "."; 
 \} 
 else 
 \{ 
  emit[2] = "."; 
 \} 
 EmitTo(\$movers[0], emit[0] + emit[2] + "\\n"+emit[3]); 
 EmitIn(placeob, emit[1] + emit[2], \$movers[0]); 
\} 
else 
\{ 
 /*Get who to send emits to*/ 
 people=allocate(0); 
 n=sizeof(placeob."base:inventory"); 
 for(i=0;i\<n;i++) 
 \{ 
  what = placeob."base:inventory"[i]; 
  if(what."udat:possessed") 
  \{ 
   people += (\{ what \}); 
  \} 
 \} 
 
 /*Send an emit to each person*/ 
 n=sizeof(people); 
 for(i=0;i\<n;i++) 
 \{ 
  emit[0] = Describe(\$movers, nil, people[i]) + " arrive"; 
  if(detail) 
  \{ 
   emit[1] = " from " + Describe(\$enterdetail, nil, people[1]) + "."; 
  \} 
  else 
  \{ 
   emit[1] = "."; 
  \} 
  EmitTo(people[i], emit[0] + emit[1]); 
  if( sizeof( (\{people[i]\}) \& \$movers) )\{ 
   \$looker = people[i]; 
   emit[3] = UnSAM(ParseXML("\<describe-view view=\\"\$(placeobject)\\" cap/\>")); 
   EmitTo(people[i], emit[3]);\} 
 \} 
\} 
 
/*break any no-longer-valid follows*/ 
n=sizeof(\$movers); 
for(i=0;i\<n;i++) 
\{ 
 if ( typeof(\$movers[i].follow) == T_OBJECT \&\& 
      \$movers[i].follow."base:environment" != placeob ) 
 \{ 
  \$movers[i].follow = nil; 
 \} 
\}
      </Core:Property>
      <Core:Property property="merry:lib:vp_change_place">
         X[M] /*
** Called when something moves to a new virtual place.
**
** Arguments:
**
**  \$movers - Who's moving to a new place.  An object or array of objects.
**  \$NewPlaceID - a value that identifies where \$movers are going.
**  \$OldPlaceID - a value that identifies where \$movers came from.
**  \$exitdetail - a string representing the detail the movers leave through in
**   the old place.  Optional.  Following will not work without it.
**  \$enterdetail - a string representing the detail the movers enter from in
**   the new place.  Optional.
**  \$follow - Whether or not to enable following.
**  \$vpid - An ID to distinguish different virtualplace events.  Only one event
**   may run per virtual system at a time.  Should be nil when called by
**   outside systems.
**
** Returns: 1 on success; throws an error on failure.
**
** Sample Call
**  Call(\$virtualsystemobject, "vp_change_place", \$movers:\$objects, \$NewPlaceId:\$val, \$OldPlaceId:\$val);
**
** Customizing:
**  This function likely does not need to be customized.
**  It's sort of the glue that holds the rest together.
**  It's good glue.
*/

/*If this constant is set, debug info will appear to \$movers and in a log when
**certain events occur.  The value of constant is also displayed to \$movers for
**context.  This info will be good for loadtesting, and should stay until some
**loadtesting is done.*/
constant DEBUG_VIRTUAL = "Virtual Place Debug: ";


int KeepMovers; /*Whether or not we need to make sure that \$movers is actually in a forest*/
int KeepOldPlace; /*Whether or not the old place needs to be preserved*/
object oldplaceob, newplaceob; /*The actual object of the old and new places*/
object invitem; /*An object inside a place*/
int initvpid; /*\$vpid on initialization*/
int i, n;

EmitTo(\$actor, "Changing place");

if (typeof(\$movers) == T_OBJECT)\{
 \$movers = (\{ \$movers \});\}
if (!\$movers \|\| typeof(\$movers) != T_ARRAY)\{
 error("virtual place - change place: Expected \$movers is not an array of objects");\}

/*Check if the there's another process in this system*/
initvpid = Int(\$vpid);
if ( !( Call(this, "vp_queue", \$function: "vp_change_place") ) )\{
 return FALSE;\}

if ( !(Call(this, "vp_validate_id", \$id: \$newplaceid)) )\{
 error("virtual place - change place: Expected \$NewPlaceID is not a valid id");\}
if ( !(Call(this, "vp_validate_id", \$id: \$oldplaceid)) )\{
 error("virtual place - change place: Expected \$OldPlaceID is not a valid id");\}

/*Determine if \$movers can be moved to storage*/
KeepMovers = Call(this, "vp_query_keep_obs");

/**Get the new place and the old place; either may be nil*/
newplaceob = Call(this, "vp_id_to_ob", \$id: \$newplaceid);
oldplaceob = Call(this, "vp_id_to_ob", \$id: \$oldplaceid);

/*Determine whether we need to keep the old place around.  This is determined
**by a seperate function which should test the following:
** If the place is a part of this particular virtual system.
** If the place is marked as a permant place.
** If the place has the correct id marked within it.
** If the place has any non-mover keepers in it.
** If there's any non-movers following any mover.
** Anything system-specific.*/
KeepOldPlace = Call(this, "vp_query_keep_place", \$placeob: oldplaceob, \$id: \$oldplaceid, \$follow: 1);
/*After that runs, \$followers is an array of all following objects.*/

/*Handle emits and anything system-specific for someone leaving the place*/
Call(this, "vp_departure", \$id: \$OldPlaceID);

EmitTo(\$actor, "1");

if(KeepOldPlace)
\{
EmitTo(\$actor, "2");
EmitTo(\$actor, dump_value(newplaceob));
 if(!newplaceob)
 \{
EmitTo(\$actor, "2.1");
  if(KeepMovers) \{
EmitTo(\$actor, "2.1.1");
   newplaceob = Call(this, "vp_create_place", \$id: \$NewPlaceID);
EmitTo(\$actor, "2.1.2");
  \} else \{
EmitTo(\$actor, "not creating place, instead clearing");
   if( Call(this, "vp_clear_place", \$id: \$OldPlaceID, \$justmovers: 1, \$storeid: \$NewPlaceID) == 0) \{
    if(!initvpid)\{
     this.runprocess = Int(this.runprocess) + 1;\}
    this.errorlog += (\{ (\{time(), "clear failed", dump_value(args) \}) \});
    error("vp_change_place - clear failed");
   \}
  \}
EmitTo(\$actor, "2.2");
 \}
\}
else
\{
EmitTo(\$actor, "3");

 if( Call(this, "vp_clear_place", \$id: \$OldPlaceID) == 0)
 \{
  if(!initvpid)\{
   this.runprocess = Int(this.runprocess) + 1;\}
  this.errorlog += (\{time(), "clear failed", dump_value(args) \});
  error("vp_change_place - clear failed");
 \}
 Call(this, "vp_set_ob_for_id", \$id: \$OldPlaceID, \$placeob: nil);

 if(newplaceob \|\| !KeepMovers)
 \{
  Slay(oldplaceob);
 \}
 else
 \{
  newplaceob = Call(this, "vp_create_place", \$placeobject: oldplaceob, \$id: \$NewPlaceID);
 \}
\}

EmitTo(\$actor, "4");


/*If there's a new place to put stuff (rather than leave it in storage)
**put it all in its place*/
if(newplaceob)
\{
 n=sizeof(\$movers);
 for(i=0;i\<n;i++)
 \{
  \$movers[i]."base:environment" = newplaceob;
  if(typeof(\$enterdetail) == T_STRING)
  \{
   \$movers[i]."base:proximity" = NewNRef(newplaceob, \$enterdetail);
  \}
 \}
 Call(this, "vp_arrival", \$id: \$NewPlaceID);
\}

/*This function is done messing with the virtual system
**See if this function is the main originating virtual place function
**for this process, and if so, mark the process done.*/
if(!initvpid)\{
 this.runprocess = Int(this.runprocess) + 1;\}

/*Now to just get those followers to follow*/
if(\$follow \&\& \$followers \&\& \$enterdetail)
\{
 if(typeof(\$enterdetail) == T_STRING)
 \{
  \$enterdetail = NewNRef(oldplaceob, \$enterdetail);
 \}
 n=sizeof(\$followers);
 for(i=0;i\<n;i++)
 \{
  Act(\$followers[i], "enter", \$what: \$enterdetail, \$vpid: nil);
 \}
\}

EmitTo(\$actor, "Finished changing place");

return 1;
      </Core:Property>
      <Core:Property property="merry:lib:vp_clear_place">
         X[M] /* 
** Clear a place of all objects within it. 
** 
** Arguments: 
** 
**  \$id - The place id of that is to be cleared 
**  \$movers - optional array of objects that are not to be registered as 
**   belonging to the place they are stored from. 
**  \$justmovers - if set, just \$movers are stored and registered, and the rest 
**   of \$id's inventory is untouched, contrary to the above behavior. 
**  \$storeid - Id of where registered objects are stored as (instead of being 
**   registered as belonging to the actual \$id); only used when \$justmovers is 
**   set, so that the movers can move out of an area, and be registered as 
**   supposed to be at somewhere else.  Which'll happen only if the movers are 
**   storable.  \$storeid to \$id by this script if \$justmovers isn't set. 
** 
** Returns: 
** 
**  1 if contents are successfully stored. 
**  0 if contents are not successfully stored. This should be avoided. 
** 
** 
** Customizing: 
**  This function should be customized for most virtual systems. 
**  It determines what it means to store objects (where each object goes) 
**  and handles things that need to be done to an object, like turning off 
**  NPC's.  This function also defines the data structure for recording the 
**  stored inventory of places (what the system uses to determine what objects 
**  to put into a place when it is remade - where the stored object belongs), 
**  which in most cases will be identical or similar to the structure of the 
**  record of the actual objects that represent each room in a place. 
**  The similarity stems that you need room objects for id's, and you also 
**  need inventories for id's; however, you do not need storage for id's of 
**  places that'll always be permanant, as they'll never need to store things, 
**  so a special id for, say, a room outside of the system, doesn't have to be 
**  considered by this sytem. 
** 
** Default Implementation: 
**  Assuming that this function hasn't been modified while leaving the comments 
**  untouched, this function assumes \$id to be a 2-dimensional int array of any 
**  size.  It also assumes the items in storage to be stored in a 2D array with 
**  elements that are either nil, or an array of stored objects.  The standard 
**  2 dimensions chosen from by \$id. 
** 
**  So that actual storage locations can be changed more easily, this 
**  implementation refers to the properties s_storage and g_storage; if they 
**  are objects, then certain objects will be stored in there; if not, those 
**  objects will be stored in nil. 
** 
** Other Notes: 
**  This function should hopefully never return 0; but there may be times when 
**  it must.  One condition might be if movement to storage doesn't properly 
**  occur.  This can be caused by: 
**  - the item not fitting in where it is supposed to go. 
**  - the item is a 'loose' combineable (requiring a 'tight' container), yet 
**    the destination is not a tight container (nil is not tight). 
**  - some other script triggers when the object is moved, that doesn't let the 
**    object enter storage.  (Note that scripts that wait until the object is 
**    moved, and wait long enough for the function to finish executing, will 
**    not cause the store to be unsuccessful.) 
*/ 
 
/*\$id is assumed to be valid, and \$storeid if \$justmovers is set*/ 
 
int i, n, immobile, initvpid; 
object placeob, what, *storables; 
 
EmitTo(\$actor, "clear:A"); 
/*Check if the there's another process in this system*/ 
initvpid = Int(\$vpid); 
if ( !( Call(this, "vp_queue", \$function: "vp_clear_place") ) )\{ 
 return FALSE;\} 
EmitTo(\$actor, "clear:B"); 
placeob = Call(this, "vp_id_to_ob"); 
EmitTo(\$actor, "clear:C"); 
if(!placeob)\{ 
 if(!initvpid)\{ 
  this.runprocess = Int(this.runprocess) + 1;\} 
 return 0; 
\} 
EmitTo(\$actor, "clear:D"); 
if(typeof(this.g_storage != T_OBJECT))\{ 
 this.g_storage = nil;\} 
if(typeof(this.s_storage != T_OBJECT))\{ 
 this.s_storage = nil;\} 
EmitTo(\$actor, "clear:E"); 
if(\$justmovers) 
\{ 
 EmitTo(\$actor, "clear:F-1"); 
 storables = \$movers; 
\} 
else 
\{ 
 EmitTo(\$actor, "clear:F-2"); 
 storables = copy(placeob."base:inventory"); 
 \$storeid = \$id; 
\} 
EmitTo(\$actor, "clear:G"); 
/*Saving the proxes needs to be done before storing anything*/ 
n=sizeof(storables); 
for(i=0;i\<n;i++) 
\{ 
 EmitTo(\$actor, "clear:H-L"); 
 what=storables[i]; 
  
 /*If the object is proximate the the place, just store the detail*/ 
 if(what."base:proximity" \&\& NRefOb(what."base:proximity") == placeob) 
 \{ 
  EmitTo(\$actor, "clear:I-L-1"); 
  what."virtualplace:storage:prox" = NRefDetail(what."base:proximity"); 
 \} 
 else /*...otherwise, store the whole NRef (or nil, as the case may be)*/ 
 \{ 
  EmitTo(\$actor, "clear:I-L-2"); 
  what."virtualplace:storage:prox" = what."base:proximity"; 
 \} 
 EmitTo(\$actor, "clear:J-L"); 
\} 
EmitTo(\$actor, "clear:K"); 
/*Now, go though each item, and store it*/ 
while(sizeof(storables)) 
\{ 
 EmitTo(\$actor, "clear:L-L"); 
 what = storables[0]; 
 /*First see about registering the object*/ 
 if( \$justmovers \|\| !\$movers \|\| sizeof( (\{what\}) \& \$movers ) == 0 ) 
 \{ 
  EmitTo(\$actor, "clear:M-L"); 
  /*Make sure that the inventory registry arrays exist and are large enough*/ 
  if( typeof(this."db:placeinventory") != T_ARRAY \|\| 
      sizeof(this."db:placeinventory") \< \$storeid[0] + 1 ) 
  \{  
   EmitTo(\$actor, "clear:N-L"); 
   this."db:placeinventory" = allocate(\$id[0] + 1); 
  \} 
  EmitTo(\$actor, "clear:O-L"); 
 
  if( typeof(this."db:placeinventory"[\$storeid[0]]) != T_ARRAY \|\| 
      sizeof(this."db:placeinventory"[\$storeid[0]]) \< \$storeid[1] + 1 ) 
  \{ 
   EmitTo(\$actor, "clear:P-L"); 
   this."db:placeinventory"[\$storeid[0]] = allocate(\$storeid[1] + 1); 
  \} 
  EmitTo(\$actor, "clear:Q-L"); 
  if (typeof(this."db:placeinventory"[\$storeid[0]][\$storeid[1]]) != T_ARRAY) 
  \{ 
   EmitTo(\$actor, "clear:R-L"); 
   this."db:placeinventory"[\$storeid[0]][\$storeid[1]] = (\{ \}); 
  \} 
  EmitTo(\$actor, "clear:S-L"); 
  /*Register the object in the db*/ 
  this."db:placeinventory"[\$storeid[0]][\$storeid[1]] += (\{ what \}); 
  EmitTo(\$actor, "clear:T-L"); 
  /*Set where the object is stored (if \$id is nil, then it's stored at nil)*/ 
  what."virtualplace:storage:id" = \$storeid; 
  what."virtualplace:storage:system" = this; 
 \} 
 
 /*if it's an awake NPC, shut it down*/ 
 if(what."nip-core:stake") 
 \{ 
  what."virtualplace:storage:npcon" = 1; 
  Call(what, "shutdown"); 
 \} 
 
 immobile = Int(what."base:immobile"); 
 what."base:immobile" = nil; 
 
 EmitTo(\$actor, "clear:U-L"); 
 /*Now, determine where to put the stored object, and put it there*/ 
 if (what."udat:possessed" \|\| what."virtualplace:keeper") 
 \{ 
  EmitTo(\$actor, "clear:V-L-1"); 
  what."base:environment" = this.s_storage; 
  if(what."base:environment" != this.s_storage) 
  \{ 
   EmitTo(\$actor, "clear:Va-L-1"); 
   what."base:environment" = nil; 
   if (what."base:environment") 
   \{ 
    EmitTo(\$actor, "clear:Vb-L-1"); 
   /*if for some reason it didn't get moved to nil, there's a problem*/ 
    if(!initvpid)\{ 
     this.runprocess = Int(this.runprocess) + 1;\} 
    return 0; 
   \}/*end if nil failulre*/ 
  \}/*end if s_storage failure*/ 
 \}/*end if important*/ 
 else 
 \{ 
  EmitTo(\$actor, "clear:V-L-2"); 
  what."base:environment" = this.g_storage; 
  if(what."base:environment" != this.g_storage)\{ 
   EmitTo(\$actor, "clear:Va-L-2"); 
   what."base:environment" = nil; 
   if (what."base:environment") 
   \{ 
    EmitTo(\$actor, "clear:Vc-L-2"); 
    /*if for some reason it didn't get moved to nil, there's a problem*/ 
    if(!initvpid)\{ 
     this.runprocess = Int(this.runprocess) + 1;\} 
    return 0; 
   \}/*end if nil failulre*/ 
  \}/*end if g_storage failure*/ 
 \}/*end if important else*/ 
 EmitTo(\$actor, "clear:W"); 
 what."base:immobile" = immobile; 
 storables -= (\{what\}); 
\}/*end while placeob.base:inventory*/ 
 EmitTo(\$actor, "clear:X"); 
 
/*This function is done messing with the virtual system 
**See if this function is the main originating virtual place function 
**for this process, and if so, mark the process done.*/ 
if(!initvpid)\{ 
 EmitTo(\$actor, "clear:Y"); 
 this.runprocess = Int(this.runprocess) + 1;\} 
EmitTo(\$actor, "clear:Z"); 
return 1;
      </Core:Property>
      <Core:Property property="merry:lib:vp_create_place">
         X[M] /* 
** Create the object for an ID if necessary, unstore the objects that belong 
** there, and do anything special that needs to be done. 
** 
** Arguments: 
** 
**  \$id - The ID of the place to be created. 
**  \$placeobject - optional; the object to be used as the new location.  A new 
**   object will be spawned if \$placeobject is not an object.  Useful for 
**   morphing. 
** 
** Returns: 
** 
**  1 if the place is successfully created. 
**  0 if the place is not successfully created.  Should never happen. 
** 
** 
** Customizing: 
**  This function should be customized for most virtual systems. 
**  It depends on what it means to store an object (where each object goes) 
**  and handles things that need to be done to an object, like turning on an 
**  NPC.  This function also depends the data structure for recording the 
**  stored inventory of places.  See the vp_store_ob customizing infor for more 
**  detail. 
** 
** Default Implementation: 
**  Assuming that this function hasn't been modified while leaving the comments 
**  untouched, this function assumes \$id to be a 2-dimensional int array of any 
**  size.  It also assumes the items in storage to be stored in a 2D array with 
**  elements that are either nil, or an array of stored objects.  The standard 
**  2 dimensions chosen from by \$id. 
** 
**  So that actual storage locations can be changed more easily, this 
**  implementation refers to the properties s_storage and g_storage; if they 
**  are objects, then certain objects will be stored in there; if not, those 
**  objects will be stored in nil. 
** 
** Other Notes: 
**  Unstorage failure is not necessarily a bad thing.  It'll likely happen 
**  occasionally.  If an item is destroyed while in storage, or gets summoned 
**  elsewhere for some reason while in storage, unstorage will fail. 
** 
*/ 
 
int initvpid, i, n; 
object what, proximate; 
string catcherror; 
EmitTo(\$actor, "a"); 
/*Check if the there's another process in this system*/ 
initvpid = Int(\$vpid); 
if ( Call(this, "vp_queue", \$function: "vp_create_place") == 0 )\{ 
 return FALSE;\} 
EmitTo(\$actor, "b"); 
/*Make sure that this place doesn't already exist*/ 
if( Call(this, "vp_id_to_ob", \$id: \$id) ) 
\{ 
 if(!initvpid) 
 \{ 
  this.runprocess = Int(this.runprocess) + 1; 
 \} 
 error ("vp_create_place - \$id is already existing."); 
\} 
EmitTo(\$actor, "c"); 
/*Get the object to use*/ 
if (typeof(\$placeobject) != T_OBJECT) 
\{ 
 if(typeof(this.placeparent) == T_OBJECT) 
 \{ 
  \$placeobject = Spawn(this.placeparent); 
 \} 
 else 
 \{ 
  error ("vp_create_place - Unable to create object for place."); 
 \} 
\} 
/*Note that some systems may need additional things done when a reusing an 
**object for a place.  This may be handled in the vp_setup_place function*/ 
EmitTo(\$actor, "d"); 
/*register the place object*/ 
Call(this, "vp_set_ob_for_id", \$placeob: \$placeobject, \$id: \$id); 
if(\$placeobject."virtualplace:system" == this)\{ 
 \$placeobject."virtualplace:id" = \$id;\} 
EmitTo(\$actor, "e"); 
/*Set details and do anything else needed*/ 
Call(this, "vp_setup_place", \$id: \$id); 
/*note that a system might need to wait until everything is unstored before 
**doing some setup actions; a seperate function should be created for that. 
**However, details should be done before unstoring, so that objects can be 
**placed properly.*/ 
EmitTo(\$actor, "f"); 
/*Verify validity of storage areas*/ 
if(typeof(this.g_storage) != T_OBJECT)\{ 
 this.g_storage = nil;\} 
if(typeof(this.s_storage) != T_OBJECT)\{ 
 this.s_storage = nil;\} 
EmitTo(\$actor, "g"); 
/*Make sure that the inventory registry arrays exist and are large enough*/ 
if( typeof(this."db:placeinventory") != T_ARRAY \|\| 
    sizeof(this."db:placeinventory") \< \$id[0] + 1 ) 
\{  
 this."db:placeinventory" = allocate(\$id[0] + 1); 
\} 
if( typeof(this."db:placeinventory"[\$id[0]]) != T_ARRAY \|\| 
    sizeof(this."db:placeinventory"[\$id[0]]) \< \$id[1] + 1 ) 
\{ 
 this."db:placeinventory"[\$id[0]] = allocate(\$id[1] + 1); 
\} 
if (typeof(this."db:placeinventory"[\$id[0]][\$id[1]]) != T_ARRAY) 
\{ 
 this."db:placeinventory"[\$id[0]][\$id[1]] = (\{ \}); 
\} 
/*clear out deleted objects*/ 
this."db:placeinventory"[\$id[0]][\$id[1]] -= (\{ nil \}); 
EmitTo(\$actor, "h"); 
/*Now, go though each item, and unstore it*/ 
/*i should stay 0 for all runnings of the loop, so that it's the first object 
**in storage each run that gets considered, and gets removed from storage. 
**however, if an item cannot be unstored, i will be increased.*/ 
i=0;  
while(i\<sizeof(this."db:placeinventory"[\$id[0]][\$id[1]])) 
\{ 
 EmitTo(\$actor, "i-1"); 
 what = this."db:placeinventory"[\$id[0]][\$id[1]][i]; 
 EmitTo(\$actor, "i-1.5"); 
 /*Determine if it's still stored, and then unstore it*/ 
 if ( (what."base:environment" == this.g_storage \|\| 
       what."base:environment" == this.s_storage ) 
    \&\& Call(this, "vp_query_ids_equal", \$id1: \$id, \$id2: what."virtualplace:storage:id") 
    \&\& what."virtualplace:storage:system" == this ) 
 \{ 
  EmitTo(\$actor, "i-2"); 
  what."base:environment" = \$placeobject; 
  /*if it got moved, deregister*/ 
  if(what."base:environment" == \$placeobject) 
  \{ 
   EmitTo(\$actor, "i-3"); 
   /*Deregister the object*/ 
   this."db:placeinventory"[\$id[0]][\$id[1]] -= (\{ what \}); 
   what."virtualplace:storage:id" = nil; 
   what."virtualplace:storage:system" = nil; 
  \}/*end if sucessfully moved*/ 
  else 
  \{ 
   EmitTo(\$actor, "i-4"); 
   i++; 
  \}/*end if else successfully moved*/ 
  EmitTo(\$actor, "i-5"); 
 \}/*end if still stored*/ 
 else 
 \{ 
  EmitTo(\$actor, "i-6"); 
 /*if it wasn't in storage, then deregister it in our own data so we don't 
  **bother with it further.  Leave the storage data in the object alone; it 
  **may be stored by a different system now.*/ 
  this."db:placeinventory"[\$id[0]][\$id[1]] -= (\{ what \}); 
 \} 
 EmitTo(\$actor, "i-7"); 
\}/*end for each stored item*/ 
EmitTo(\$actor, "j"); 
/*With everything unstored, proxes should be set.*/ 
n=sizeof(\$placeobject."base:inventory"); 
for(i=0;i\<n;i++) 
\{ 
 EmitTo(\$actor, "k"); 
 what=\$placeobject."base:inventory"[i]; 
  
 /*If the stored prox is supposed to be an object, see if that object's still 
 **in the area, and if so, set the prox*/ 
 \$prox = what."virtualplace:storage:prox"; 
 if( typeof(\$prox) == T_OBJECT \&\& 
     Get(NRefOb(\$prox), "base:environment") == \$placeobject ) 
 \{ 
  what."base:proximity" = \$prox; 
 \} 
 else  
 \{ 
  /*If prox is a string, it may refer to an existing detail in the place; 
  **check if that detail does exist, and isn't hidden.  If the check passes, 
  **set the prox appropriately*/ 
  if ( typeof(\$prox) == T_STRING \&\&  
       Get(\$placeobject, "details:"+\$prox+":snames") \&\& 
       !(Get(\$placeobject, "details:"+\$prox+":hidden")) ) 
  \{ 
   what."base:proximity" = NewNRef(\$placeobject, \$prox); 
  \} 
 \} 
 /*And in any case, the stored prox should be nil'd.*/ 
 what."virtualplace:storage:prox" = nil; 
\} 
EmitTo(\$actor, "l"); 
/*Finally, wait a bit, then if the place still exists, turn on any off NPC's*/ 
/*Because there's a delay, and we want to allow the virtual system to keep 
**functioning while the delay is in process, we release control of the system*/ 
 
/*This function is done messing with the virtual system 
**See if this function is the main originating virtual place function 
**for this process, and if so, mark the process done.*/ 
if(!initvpid)\{ 
 this.runprocess = Int(this.runprocess) + 1;\} 
 
/*This delay keeps NPC's from being started up when someone's just passning 
**through.  Depending on the system, it might be a good idea to tweak, or even 
**greatly increase this delay.  It's perfectly feasible that, say, the wildlife 
**in a forest wouldn't be doing anything noticeable for 30 seconds after 
**someone's arrival; they'd be hiding from the newcomer.  Though things that 
**need to respond to the player will need to be started up sooner. 
**Guards would need to respond immidiately to players trying to get past 
**somewhere.  A deer being pursued might be marked as a keeper, so that he's 
**already started when the hunter arrives; unpursued boars could revert to 
**normal.*/ 
EmitTo(\$actor, "m"); 
\$delay(2.0, \$placeobject, "bde4"); 
EmitTo(\$actor, "n"); 
/*At this point, if we were going to actually do something to the virtual 
**system, we'd need to reclaim control.  In which case we'd probably need to 
**make this remainder a seperate function.  But just starting NPC's doesn't 
**mess with the virtual system any*/ 
 
/*If the \$placeobject still exists and still has the same id, start up the 
**NPC's.*/ 
if(\$placeobject \&\& \$placeobject."virtualplace:id" == \$id) 
\{ 
 n=sizeof(\$placeobject."base:inventory"); 
 for(i=0;i\<n;i++) 
 \{ 
  what = \$placeobject."base:inventory"[i]; 
  /*See if it's an NPC, and if it was marked for bringing back*/ 
  if(what."virtualplace:storage:npcon" \&\& what."npc:state" != "ALIVE") 
  \{ 
   /*One NPC having problems shouldn't stop restoring the rest*/ 
   if( catcherror = catch(Call(what, "heartbeat")) ) /*Assignment on purpose*/ 
   \{ 
    if( typeof(this.errorlog) != T_ARRAY )\{ 
     this.errorlog = allocate(0);\} 
    this.errorlog += (\{ time(), "Error starting NPC; vsys unaffected", what, catcherror \}); 
   \}/*end if error*/ 
  \}/*end if rebirth*/ 
 \}/*end for inventory*/ 
\}/*end if place still around*/ 
EmitTo(\$actor, "o"); 
return 1;
      </Core:Property>
      <Core:Property property="merry:lib:vp_departure">
         X[M] /* 
** Do anything special that needs to be done when an object departs from a 
**  place, including describing how they leave. 
** 
** Arguments: 
** 
**  \$movers - Array of objects that are leaving. 
**  \$id - The place they are leaving from. 
**  \$enterdetail - Optional string or Nref of the detail that the movers are 
**   leaving through.  If a string, it is assumed to be a detail of the place. 
** 
** Customizing: 
**  This function might be customized for many virtual systems. 
**  The primary purpose of this function is to just display emits of \$movers 
**  leaving; this may vary depending on situation.  Examples: 
**   [movers] leave through [detail]. 
**    Bob leaves through a wooden door. 
**    The women leave through an arch. 
**   [movers] [gait] away [detail]. 
**    Mary walks away through a wooden door. 
**    John and Sue crawl away through an arch. 
**   [movers] departs down [detail], to the [direction]. 
**    Tom departs down a sparse path, to the east. 
**    Beth and Jane depart down a paved walkway, to the north. 
**  ...etc.  What's appropriate can vary; the factor most likely to make a 
**  that you can't really leave 'through' a path, as that makes little sense.  
** 
** Default Implementation: 
**  Just displays an emit, something like "Bob leaves via a door." 
**  Standard EmitTo person, EmitIn room for everyone else when just one mover. 
**  With multiple movers, an emit is generated for each possessed object in the 
**  room. 
*/ 
 
/*\$id is assumed to be valid*/ 
 
int i, n, detail; 
object placeob, *people, what; 
string *emit; 
 
/*We need movers and a place to move them from to do anything*/ 
if(!\$movers \|\| typeof(\$movers) != T_ARRAY \|\| sizeof(\$movers) == 0)\{ 
 return 0;\} 
 
placeob = Call(this, "vp_id_to_ob"); 
 
if(!placeob)\{ 
 return 0;\} 
 
/*Get the detail, if any*/ 
if(typeof(\$enterdetail) == T_STRING) 
\{ 
 \$enterdetail=NewNRef(placeob, \$enterdetail); 
\} 
if( typeof(\$enterdetail) == T_OBJECT \&\&  
    Get(NRefOb(\$enterdetail), "details:default:description:brief") ) 
\{ 
 detail=1; 
\} 
 
/*There's no easy way exclude multiple movers in an EmitIn, so if there's 
**more than one, do the emit by brute force; if just one, do it the easy way.*/ 
 
emit=allocate(3); 
if(sizeof(\$movers) == 1) 
\{ 
 emit[0] = "You leave " + Describe(placeob, nil,\$movers[i]); 
 emit[1] = Describe(\$movers[0]) + " leaves"; 
 if(detail) 
 \{ 
  emit[2] = " via " + Describe(\$enterdetail) + "."; 
 \} 
 else 
 \{ 
  emit[2] = "."; 
 \} 
 EmitTo(\$movers[0], emit[0] + emit[2]); 
 EmitIn(placeob, emit[1] + emit[2], \$movers[0]); 
\} 
else 
\{ 
 /*Get who to send emits to*/ 
 people=allocate(0); 
 n=sizeof(placeob."base:inventory"); 
 for(i=0;i\<n;i++) 
 \{ 
  what = placeob."base:inventory"[i]; 
  if(what."udat:possessed") 
  \{ 
   people += (\{ what \}); 
  \} 
 \} 
   
 /*Send an emit to each person*/ 
 n=sizeof(people); 
 for(i=0;i\<n;i++) 
 \{ 
  emit[0] = Describe(\$movers, nil, people[i]) + " leave"; 
  if(detail) 
  \{ 
   emit[1] = " via " + Describe(\$enterdetail, nil, people[i]) + "."; 
  \} 
  else 
  \{ 
   emit[1] = "."; 
  \} 
  EmitTo(people[i], emit[0] + emit[1]); 
 \} 
\}
      </Core:Property>
      <Core:Property property="merry:lib:vp_id_to_ob">
         X[M] /* 
** Finds the object associated with a virtual place ID, if it exists. 
** 
** Arguments: 
** 
**  \$id - the id to find the object for. 
** 
** Returns: the object, if it exists, or nil if not. 
** 
**  This function should be unique for each virtual place, as it is dependent 
**   the data type of the ID and defines the storage structure for the objects 
**   associated with each place ID. 
**   This version (unless this function was customized and these comments were 
**   not) assumes \$id to be a 2-dimensional int array of any size, and the 
**   objects themselves to be stored in a 2D array, with nils in blank spots. 
*/ 
 
/*\$id is assumed to be validated already; however a nil \$id, while valid 
**means no object for this system*/ 
if(!\$id)\{ 
 return nil;\} 
 
return (this."db:locationobjects"[\$id[0]][\$id[1]]);
      </Core:Property>
      <Core:Property property="merry:lib:vp_query_ids_equal">
         X[M] /* 
** Determine if two place id's are equal. 
** This is necessary as a simple equality test cannot be done with some data 
**  types. 
** 
** Arguments: 
** 
**  \$id1 - One ID to test. 
**  \$id2 - The other ID to test. 
** 
** Returns: 
**  1 if they are equal 
**  0 if they are not equal 
** 
** Note: 
**  This function should be customized for some virtual systems. 
**  It'll correctly determine equality with all that == will do, and will 
**  also handle 1-dimensional arrays, but cannot handle mappings or complicated 
**  arrays. 
**  Should more complicated analysis be deemed necessary, then editing the base 
**  version of this function may be considered, if the change won't cause an 
**  undue burden on the server when this function is called by systems that 
**  don't use the extra analysis. 
**  Also, a virtual system may for some reason want to consider two values that 
**  are not actually equal to be equivalent ID's.  The likeliest example would 
**  be an array-based system that also assigns string names to some places. 
**  This would likely take more editing than just this function, but I believe 
**  it to be possible, though not really ever necessary. 
*/ 
 
int i, n; 
 
/*make sure they have the same types*/ 
if (typeof(\$id1) != typeof(\$id2)) 
 return 0; 
 
/*if they are not arrays or mappings, then a standard == will do the trick.*/  
if (typeof(\$id1) \< T_ARRAY) 
 return ( \$id1 == \$id2 ); 
 
/*if they are mapping or of a type not accounted for here (which should never 
**happen), then we can't determine equality.  Anything other than array or 
**mapping should have been handled already by this point.*/ 
if (typeof(\$id1) != T_ARRAY) 
 return 0; 
/*note that a test for mappings, placed within an if block, would be 
**acceptable; however, any kind of mapping test won't be too easy on the 
**system*/ 
 
 
/*All other choices being eliminated, it's an array.*/ 
/*Make sure they're the same size.  'n' is set and used here because it's used 
**later.*/ 
n = sizeof(\$id1); 
if (n != sizeof(\$id2)) 
 return 0; 
 
/*Test each item and see if they are equal*/ 
for(i=0; i\<n; i++) 
\{ 
 /*note that a simple != test is done, which will return 0 if the arrays either 
 **have arrays within them (multidimensional arrays), or have mappings within 
 **them.  This function could be made recursive, with a callback to this 
 **function for each test, but that would be more work than necessary for tests 
 **on simple arrays*/ 
 if(\$id1[i] != \$id2[i]) 
  return 0; 
\} 
 
/*All the tests have passed, so they are consideered equal*/ 
return 1;
      </Core:Property>
      <Core:Property property="merry:lib:vp_query_keep_obs">
         X[M] /* 
** Determine if a group of objects can be tossed into virtual storage (whatever 
**  that storage may be), or if their virtual place must be maintained. If any. 
** 
** Arguments: 
** 
**  \$movers - who's moving to a new place.  Array of objects. 
** 
** Returns: 
**  A nonzero integer if they must be maintained. 
**  0 if they can be stored. 
** 
** Note: 
**  This function should probably be customized for each virtual system. 
**  The most common customization will likely be what to do to NPC's and when. 
**  Storing an NPC if it's not seen any PC's in a while might be an option. 
*/ 
 
int Keep, i, n; 
n=sizeof(\$movers); 
for(i=0; i\<n \&\& !Keep; i++)\{ 
 Keep = Int(\$movers[i]."udat:possessed") + Int(\$movers[i]."virtualplace:keeper");\} 
return Keep;
      </Core:Property>
      <Core:Property property="merry:lib:vp_query_keep_place">
         X[M] /* 
** Determine if a single room should be maintained, or can be safely deleted 
**  after tossing all its contents into storage.  Minus perhaps some objects 
**  that might be leaving soon. 
**  Also can determine what objects should be followers, and return an array 
**  of followers, if there are any. 
** 
** Arguments: 
** 
**  \$placeob - The place to test.  An object. 
**  \$id - The id of the place. 
**  \$movers - Objects to exclude when testing if individual objects need to 
**   be maintained.  An array of objects.  Optional. 
**  \$follow - If set, followers should be checked. 
** 
** Returns: 
**  A nonzero integer if it must be maintained. 
**  0 if it can be stored. 
** 
** Thread variables set: 
**  \$followers - Set to an array of followers.  Empty array if none are found. 
** 
** Note: 
**  This function should probably be customized for some virtual systems. 
**  A customization might include a timer such that any place recently visited 
**  by a PC is kept around for a short while, allowing internal processes to 
**  run, and NPC's interact (though NPC's might be better off with their own 
**  timer). 
*/ 
 
int i, j, n, m, Keep; 
object *inv, *followers; 
 
/*If we don't know where you're talking about, just say Keep and ignore followers 
**there's no way for us to even tell who would qualify as a follower*/ 
if(typeof(\$placeob) != T_OBJECT) 
 return 1; 
 
/*The following code block should remain in */ 
Keep = (\$placeob."virtualplace:permanantplace" \|\|  /*Is it marked permanant?*/ 
        \$placeob."virtualplace:system" != this \|\|  /*Is it in this system?*/ 
        Call(this, "vp_query_ids_equal", \$id1: \$id, \$id2: \$placeob."virtualplace:id") == 0);   /*same as the place's id*/ 
 
/*Here would be a good place for any code that doesn't look at every 
**object in \$place's inventory.*/ 
 
/*Get the inventory items to check*/ 
inv = copy(\$placeob."base:inventory"); 
 
if (\$movers)\{ 
 inv -= \$movers; 
 m=sizeof(\$movers); 
\} 
 
/*Test if any of the inventory should be kept based on own merit*/ 
Keep += Call(this, "vp_query_keep_obs", \$movers: inv); 
 
/*Test if any of the inventory is following a mover*/ 
 
if(\$follow \&\& \$movers) 
\{ 
 \$followers=allocate(0); 
 /*go through each of inv ...*/ 
 n=sizeof(inv); 
 for(i=0; i\<n; i++) 
 \{ 
  /*... and see if that inv is following a mover*/ 
  /*m was set to sizeof movers earlier*/ 
  for(j=0; j\<m; j++) 
  \{ 
   if (inv[i].follow == \$movers[j]) 
   \{ 
    \$followers += (\{ inv[i] \}); 
    Keep=1; 
   \}/*end if an inv is following a mover*/ 
  \}/*end for each \$mover*/ 
 \}/*end for each inv*/ 
\}/*end if testing followers*/ 
 
return Keep;
      </Core:Property>
      <Core:Property property="merry:lib:vp_queue">
         X[M] /* 
** Called when the system is busy, and another call to it is made; puts the 
** new call in a queue. Throws an error if the system stays busy for too long. 
** 
** Arguments: 
** 
**  \$vpid - The virtual process id. 
**  \$function - The function being called. 
**  Any variables needed by the function. 
** 
** Returns: 
** 
**  1 - if the function can run 
**  0 - if the function is put in the queue, and should exit 
** 
** Sets the thread variable \$vpqueuei to nil. 
** 
**  Notes: 
**   Any process that modifies a virtual system should have a \$vpid, and be put 
**   on hold if another function is using that virtual system.  The process is 
**   like this: 
**   1. A function, call it Function X, is called. 
**   2. X does any initial errorchecking of \$variables. 
**   3. X sets a local variable (initvpid is good) equal to \$vpid.  \$vpid 
**      should be nil at this point; only this function ever set \$vpid. 
**      If a thread variable must be used instead of a local variable (due to 
**      \$delays), that thread variable must be set to something in every call 
**      to another function. 
**   4. X calls this function, passing X's name as \$function. 
**   5. If this function returns 0: 
**    a. X exits immidiately. 
**    b. This function repeatedly waits \$delays for random tenths of a second 
**       until it detects that it is X's turn to run; this function then calls 
**       X again.  This time, when X gets to this function again, this function 
**       should return a 1. 
**   6. If this function returns 1: 
**    a. X continues execution. 
**    b. When X is done doing things to the virtual system, it checks the local 
**       variable initially set to \$vpid.  If that variable is nil, X sets the 
**       virtual system's object's "runprocess" property to 1 greater than it 
**       was before, as an integer.  If X is running in that function; sample: 
**        this."runprocess" = Int(this."runprocess") + 1; 
**       This lets the system know that it's the next process's turn to run. 
** 
*/ 
 
float n; 
 
/*We need a function to call*/ 
if ( !(FindMerry(this, "lib", \$function)) )\{ 
 error ("vp_queue - invalid \$function");\} 
 
if (this == \$\{orcsuit:Lib:newvp\})\{ 
 error ("vp_queue - function run in actual lib - these functions are meant to be inherited!");\} 
 
/*Make sure that the errorlog can be added to 
**Note that by doing this here, this becomes no longer needed in other 
**individiual functions that call this one.*/ 
if (typeof(this.errorlog) != T_ARRAY)\{ 
 this.errorlog = allocate(0);\} 
 
this.runprocess = Int(this.runprocess); 
this.nextprocess = Int(this.nextprocess); 
 
/*If the process doesn't have a \$vpid, give it the next unassigned process*/ 
if(!\$vpid)\{ 
 \$vpid = this.nextprocess; 
 this.nextprocess = \$vpid +1; 
\} 
 
/*If the process is the one currently allowed in line, let it run*/ 
if (\$vpid == this.runprocess)\{ 
 return 1;\} 
 
/*It isn't the one currently allowed; it must wait*/ 
 
\$vpqueuei = 0.0; 
while(\$vpqueuei\<10.0) 
\{ 
 n = Flt(random(10))/10.0; 
 \$vpqueuei += n; 
 \$delay(n, 0, "8aeb"); 
 if (\$vpid == this.runprocess) 
 \{ 
  Call(this, \$function); 
  return 0; 
 \} 
\} 
 
/*If after 10 seconds it still can't be done, throw an error*/ 
this.errorlog += (\{ (\{ time(), "vp_queue - wait timeout", this.nextprocess, this.runprocess, \$vpid, args \}) \}); 
error ("vp_queue - wait timeout");
      </Core:Property>
      <Core:Property property="merry:lib:vp_set_ob_for_id">
         X[M] /* 
** Sets an object to represent a place ID. 
** 
** Arguments: 
** 
**  \$id - the id to set the object to. 
**  \$placeob - the object to set to the id.  If nil, it removes the any 
**   any object associated with the id.from the registry. 
**  \$vpid - virtual place id. 
** 
**  This function should be unique for each virtual place, as it is dependent 
**   the data type of the ID and the storage structure for the objects 
**   associated with each place ID. 
**   This version (unless this function was customized and these comments were 
**   not) assumes \$id to be a 2-dimensional int array of any size, and the 
**   objects themselves to be stored in a 2D array, with nils in blank spots. 
*/ 
 
int initvpid; 
 
EmitTo(\$actor, "set_ob_for_id" + dump_value(args)); 
/*Check if the there's another process in this system*/ 
initvpid = Int(\$vpid); 
if ( Call(this, "vp_queue", \$function: "vp_set_ob_for_id") == 0 )\{ 
 return FALSE;\} 
 
/*\$id is assumed to be validated already; however, we shouldn't be registering 
**a place for nil*/ 
if (!\$id)\{ 
 return FALSE;\} 
 
/*Register the object*/ 
this."db:locationobjects"[\$id[0]][\$id[1]] = \$placeob; 
 
/*Note that virtualplace:system and virtualplace:id are not set here. 
**All this function should do is register the object in the system; it should 
**not mess with the object in any way.  This is in part so that an outside room 
**can be given an ID and reference, without that room being an actual part of 
**the system.*/ 
 
/*This function is done messing with the virtual system 
**See if this function is the main originating virtual place function 
**for this process, and if so, mark the process done.*/ 
if(!initvpid)\{ 
 this.runprocess = Int(this.runprocess) + 1;\}
      </Core:Property>
      <Core:Property property="merry:lib:vp_validate_id">
         X[M] /* 
** Determines whether a value is a valid place identifier for a virtual system. 
** 
** Arguments: 
** 
**  \$id - the value to be tested for validity. 
** 
** Returns: 0 if invalid, 1 if valid. 
** 
**  This function should be unique for each virtual place, as it both defines 
**   the spatial area that the virtual place represents, and the data type used 
**   to refer to each invidual point in that area. 
**   This version (unless this function was customized and these comments were 
**   not) is for a 10x10 area, with an array used to identify each point, going 
**   from integer 0 to integer 9 in each of two elements. 
*/ 
 
/*nil id's are considered valid; just means that they are from or going to 
**a place outside the system*/ 
if (!\$id) 
 return 1; 
 
/*Each of these tests are run in turn; as soon as one fails, the whole test 
**exits immidiately, returning the false value.  Only if all test run and 
**succeed is a true value returned*/ 
 
return (typeof(\$id) == T_ARRAY \&\& 
        sizeof(\$id) == 2 \&\& 
        typeof(\$id[0]) == T_INT \&\& 
        typeof(\$id[1]) == T_INT \&\& 
        \$id[0] \<= 9 \&\& \$id[0] \>= 0 \&\& 
        \$id[1] \<= 9 \&\& \$id[1] \>= 0);
      </Core:Property>
      <Core:Property property="merry:lib:vpq_variant">
         X[M] /* 
** Picks out a string variant for some part of the system. 
** 
** Arguments: 
** 
**  \$ID - The virtual place ID to get the value for. Any valid ID value. 
**  \$data - The data set to get a value from. String. 
**  \$version - What permutation of the data to use. Optional, any value. 
** 
** Returns: a string variant, possibly empty. 
** 
**  This function is optional for virtual systems, but very useful for quickly writing SAM descriptions using \<vdesc/\>, or for determining what nsmaes to give a detail.  All that's here at the moment is a placeholder, though. 
So that common code can be shared while each virtual system has thier own setups, this function is designed to call vp_query_variant_std, which does the same thing as this function, except that function's not meant to be changed.  Use the other function as a fallback, or call it first with the \$nodefault variable set to check some values before doing your own custom math. 
*/ 
 
return Call(this, "vpq_variant_std");
      </Core:Property>
      <Core:Property property="merry:lib:vpq_variant_int">
         X[M] /* 
** D=Gets an integer value for an ID associated with a data value. 
** 
** Arguments: 
** 
**  \$ID - The virtual place ID to get the value for. Any valid ID value. 
**  \$data - The data set to get a value from. String. 
**  \$version - What permutation of the data to use. Optional, any value. 
** 
** Returns: 
**  An integer value. 
** 
** Notes: 
**  The primary purpose of this function is to serve up numbers used to access 
**  arrays. Therefore, it should try to determine if there is an array that 
**  matches \$data, and if so, limit the return value to the sixe of that array. 
** 
** Customization: 
**  This will get you good randomization with little effort. If you want 
**  specific patterns or clumping or whatnot, you'll have to write your own. 
**  Use the demo forest (currently at orcsuit:Db:newvforest) for old examples. 
*/ 
 
string prop; 
float max; 
 
if(typeof(\$data) == T_STRING) 
\{ 
 prop = "data:variant:"+\$data; 
 if(typeof(Get(this, prop)) == T_ARRAY) 
  max = Flt(sizeof(Get(this, prop))); 
\} 
 
return math::pseudorandom(\$seed: \$id, \$salt: (\{\$data, \$version\}), \$max: max);
      </Core:Property>
      <Core:Property property="merry:lib:vpq_variant_std">
         X[M] /* 
** Picks out generalized variant data. 
** 
** Arguments: 
** 
**  \$ID - The virtual place ID to get the value for. Any valid ID value. 
**  \$data - The data set to get a value from. String. 
**  \$version - What permutation of the data to use. Optional, any value. 
**  \$nodefault - If set, don't make up default values. Optional, boolean. 
** 
** Returns: a string variant, possibly empty. 
** 
** This function's partner is vp_query_variant (notice the std is left out).  Both do the same thing - turn a \$data and \$id into a string, primarily for setting details according to room ID. 
** The difference, is, this function is not meant to be customized; it has specific responses to certain \$data values, and can do a 'catchall' function with most others. 
** The way this is meant to work, is all calls will normally go to the other function, which can have customization; that other function then calls this one if it doesn't know what to do.  Or, the other function could all this one with \$nodefault set, having this function try its set things, and if those don't work, let the other function then try its own stuff. 
*/ 
 
int ivar; 
mixed data, svars; 
data = \$data; 
 
if(typeof(data)==T_STRING) 
 data = lower_case(data); 
 
switch(data)\{ 
 case "id": 
  return dump_value(\$id); 
  break; 
 case "time": 
  return ctime(time()); 
  break; 
 case nil: 
  return "[no data for variant]"; 
  break; 
 case "system": 
  return dump_value(this); 
  break; 
 case "foo": 
  return "bar"; 
  break; 
 default: 
  if(\$nodefault) 
   return ""; 
  ivar = Int( Call(this, "vpq_variant_int") ); 
  if( typeof(data) == T_STRING ) 
  \{ 
   data = "data:variant:"+data; 
   svars = Get(this, data); 
   if( typeof(svars) == T_ARRAY) 
   \{ 
    if(sizeof(svars) \> ivar) 
     return Str(svars[ivar]); /*This here is the correct return.  Any other return after the \$nodefault return is just a 'best we can do' value*/ 
    return "[" + data + "[" + Str(ivar) + "]]"; 
   \} 
   return Str(svars); /*It's supposed to be an array, but if not, just return whatever's there.*/ 
  \} 
  return Str(ivar); /*Let'em know what there should be a value for*/ 
  break; 
\}
      </Core:Property>
      <Core:Property property="revisions">
         (\{ 1071634303, "orcsuit", "E", 1071679681, "orcsuit", "E", 1071681274, "orcsuit", "E", 1071682859, "orcsuit", "E", 1071682924, "orcsuit", "E", 1071682958, "orcsuit", "E", 1071684439, "orcsuit", "E", 1071684697, "orcsuit", "E", 1071685125, "orcsuit", "E", 1071685221, "orcsuit", "E", 1071692202, "orcsuit", "E", 1071692292, "orcsuit", "E", 1071692909, "orcsuit", "E", 1071693452, "orcsuit", "E", 1071694106, "orcsuit", "E", 1071694599, "orcsuit", "E", 1071695411, "orcsuit", "E", 1071695632, "orcsuit", "E", 1071696455, "orcsuit", "E", 1071697435, "orcsuit", "E", 1071697535, "orcsuit", "E", 1071698015, "orcsuit", "E", 1071698061, "orcsuit", "E", 1071701163, "orcsuit", "E", 1071701296, "orcsuit", "E", 1071701369, "orcsuit", "E", 1071701797, "orcsuit", "E", 1071702504, "orcsuit", "E", 1071702700, "orcsuit", "E", 1071703011, "orcsuit", "E", 1071704016, "orcsuit", "E", 1071704224, "orcsuit", "E", 1071704310, "orcsuit", "E", 1071704386, "orcsuit", "E", 1071704520, "orcsuit", "E", 1071707621, "orcsuit", "E", 1071711799, "orcsuit", "E", 1071715926, "orcsuit", "E", 1071717124, "orcsuit", "E", 1071717232, "orcsuit", "E", 1071717337, "orcsuit", "E", 1071717625, "orcsuit", "E", 1071717718, "orcsuit", "E", 1071718046, "orcsuit", "E", 1071718618, "orcsuit", "E", 1071720049, "orcsuit", "E", 1071723354, "orcsuit", "E", 1071725775, "orcsuit", "E", 1071727253, "orcsuit", "E", 1071727599, "orcsuit", "E", 1071731422, "orcsuit", "E", 1071731790, "orcsuit", "E", 1071732034, "orcsuit", "E", 1071732345, "orcsuit", "E", 1071732695, "orcsuit", "E", 1071733033, "orcsuit", "E", 1071733295, "orcsuit", "E", 1071733363, "orcsuit", "E", 1071733492, "orcsuit", "E", 1073949653, "orcsuit", "E", 1073950197, "orcsuit", "E", 1074036425, "orcsuit", "E", 1074036665, "orcsuit", "E", 1074036890, "orcsuit", "E", 1074044578, "orcsuit", "E", 1074045475, "orcsuit", "E", 1074046561, "orcsuit", "E", 1074047603, "orcsuit", "E", 1074049012, "orcsuit", "E", 1074051112, "orcsuit", "E", 1074051950, "orcsuit", "E", 1074052201, "orcsuit", "E", 1074053127, "orcsuit", "E", 1074053929, "orcsuit", "E", 1074057454, "orcsuit", "E", 1074057475, "orcsuit", "E", 1074058599, "orcsuit", "E", 1074058862, "orcsuit", "E", 1074064811, "orcsuit", "E", 1074065096, "orcsuit", "E", 1074118031, "orcsuit", "E", 1074118296, "orcsuit", "E", 1074119987, "orcsuit", "E", 1074121024, "orcsuit", "E", 1074147765, "orcsuit", "E", 1074155416, "orcsuit", "E", 1074155540, "orcsuit", "E", 1074156482, "orcsuit", "E", 1074296375, "orcsuit", "E", 1074487397, "orcsuit", "E", 1074505049, "orcsuit", "E", 1074506722, "orcsuit", "E", 1077028079, "orcsuit", "E", 1077047915, "orcsuit", "E", 1079580882, "orcsuit", "E", 1079581961, "orcsuit", "E", 1079604550, "orcsuit", "E", 1079604710, "orcsuit", "E", 1079855842, "orcsuit", "E", 1079861233, "orcsuit", "E", 1079861260, "orcsuit", "E", 1079861316, "orcsuit", "E", 1079861519, "orcsuit", "E", 1079984848, "orcsuit", "E", 1079985019, "orcsuit", "E", 1079985288, "orcsuit", "E", 1079985360, "orcsuit", "E", 1079985377, "orcsuit", "E", 1079985405, "orcsuit", "E", 1079985673, "orcsuit", "E", 1079985960, "orcsuit", "E", 1079985977, "orcsuit", "E", 1079986034, "orcsuit", "E", 1079995412, "orcsuit", "E", 1080284015, "orcsuit", "E", 1080284030, "orcsuit", "E", 1080285771, "orcsuit", "E", 1081360541, "orcsuit", "E", 1081361002, "orcsuit", "E", 1081361194, "orcsuit", "E", 1081361478, "orcsuit", "E", 1081371199, "orcsuit", "E", 1082608494, "orcsuit", "E", 1082662403, "orcsuit", "E", 1090583270, "orcsuit", "E", 1238989505, "thefireduck", "E", 1238992816, "thefireduck", "E", 1238993866, "thefireduck", "E", 1238994001, "thefireduck", "E", 1238994210, "thefireduck", "E", 1238995791, "thefireduck", "E", 1238995871, "thefireduck", "E", 1238996012, "thefireduck", "E", 1264320055, "tonyd", "X", 1264918974, "tonyd", "P", 1264926884, "tonyd", "P", 1264926935, "tonyd", "P", 1264926969, "tonyd", "P", 1264927032, "tonyd", "P", 1264927101, "tonyd", "P", 1264927226, "tonyd", "P", 1264927418, "tonyd", "P", 1264927460, "tonyd", "P", 1264927580, "tonyd", "P", 1264927612, "tonyd", "P" \})
      </Core:Property>
    </Core:PCProperties>
    <Notes:Notes/>
  </Core:PropertyContainer>
</object>
